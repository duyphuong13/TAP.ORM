using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Threading.Tasks;
using TAP.Core.DatastoreORM.DAO;
using Google.Cloud.Datastore.V1;
using Google.Protobuf.WellKnownTypes;
using Type = System.Type;
using Value = Google.Cloud.Datastore.V1.Value;

namespace TAP.Core.DatastoreORM.Repository
{
    public abstract class DatastoreRepository<TEntity, TKey> : IRepository<TEntity, TKey> where TEntity : BaseDAO
    {

        protected static string _kind;
        protected readonly DatastoreDb _db;
        private static TypesMetadataLoader _typesMetadataLoader;
        private static KindKeyInfo _kindKeyInfo;

        protected DatastoreRepository(string projectId)
        {
            if (_kindKeyInfo == null)
                LoadKindInfo();

            _db = DatastoreDb.Create(projectId);

            if (_typesMetadataLoader == null)
                _typesMetadataLoader = new TypesMetadataLoader(typeof(TEntity));

        }
        private void LoadKindInfo()
        {
            var kindAttribute = typeof(TEntity).GetCustomAttribute(typeof(KindAttribute));
            if (kindAttribute != null)
            {
                _kind = ((KindAttribute)kindAttribute).Kind;
            }

            var properties = typeof(TEntity).GetProperties();
            var propertiesWithKeyAttributeCount = 0;
            foreach (var property in properties)
            {
                var keyAttribute = property.GetCustomAttribute<KindKeyAttribute>();
                if (keyAttribute != null)
                {
                    _kindKeyInfo = new KindKeyInfo
                    {
                        IsAutoGenerated = keyAttribute.IsAutoGenerated,
                        KeyName = property.Name
                    };
                    propertiesWithKeyAttributeCount++;
                }
            }

            if (propertiesWithKeyAttributeCount != 1)
            {
                string errorMsg = propertiesWithKeyAttributeCount > 1 ? "Too many keys defined - only one allowed." : "Missing required key attribute - make sure you've added KindKey attribute on one of the properties.";
                throw new Exception(errorMsg);
            }
        }


        private TKey GetId(Key key)
        {
            object id;
            if (typeof(TKey) == typeof(long))
            {
                id = key.Path.First().Id;
            }
            else
            {
                id = key.Path.First().Name;
            }
            return (TKey)id;
        }
        private TKey GetId(TEntity obj)
        {
            var keyPropertyAccessors = GetKeyPropertyAccessors();
            var id = keyPropertyAccessors.Get(obj);
            return (TKey)id;
        }
        private void SetId(TEntity obj, TKey key)
        {
            var keyPropertyAccessors = GetKeyPropertyAccessors();
            keyPropertyAccessors.Set(obj, key);
        }

        private Key BuildKey(TKey id)
        {
            var keyFactory = _db.CreateKeyFactory(_kind);
            return typeof(TKey) == typeof(long) ? keyFactory.CreateKey(Convert.ToInt64(id)) : keyFactory.CreateKey(Convert.ToString(id));
        }
        private Key GetKey(TEntity obj, bool isUpdate = false)
        {
            Key key;
            if (_kindKeyInfo.IsAutoGenerated && !isUpdate)
            {
                key = _db.CreateKeyFactory(_kind).CreateIncompleteKey();
            }
            else
            {
                var keyPropertyAccessors = GetKeyPropertyAccessors();
                var id = keyPropertyAccessors.Get(obj);
                key = BuildKey((TKey)id);
            }
            return key;
        }
        private Accessors GetKeyPropertyAccessors()
        {
            var keyProperty = _typesMetadataLoader.GetTypeMetadata(typeof(TEntity)).PropertiesInfo[_kindKeyInfo.KeyName];
            return keyProperty;
        }

        protected Entity BuildEntity(TEntity obj, bool isUpdate = false)
        {
            var entity = ToEntity(obj);
            entity.Key = GetKey(obj, isUpdate);
            return entity;
        }
        private Entity ToEntity(object obj)
        {
            var entity = new Entity();

            var typeMetadata = _typesMetadataLoader.GetTypeMetadata(obj.GetType());

            foreach (var type in typeMetadata.PropertiesInfo)
            {
                var val = type.Value.Get(obj);
                if (type.Key != _kindKeyInfo.KeyName) // Not the key
                {
                    entity.Properties.Add(type.Key, CreateValueFromObject(val, IsExcludeColumnFromIndex(type.Value.CustomAttributes)));
                }
            }

            return entity;
        }
        private Value CreateValueFromObject(object obj, bool isExcludeFromIndex = false)
        {
            var value = new Value { ExcludeFromIndexes = isExcludeFromIndex };
            if (obj == null)
            {
                value.NullValue = NullValue.NullValue;
                return value;
            }

            var type = obj.GetType();
            if (type == typeof(string))
            {
                value.StringValue = (string)obj;
            }
            else if (type == typeof(int))
            {
                value.IntegerValue = (int)obj;
            }
            else if (type == typeof(long))
            {
                value.IntegerValue = (long)obj;
            }
            else if (type == typeof(double))
            {
                value.DoubleValue = (double)obj;
            }
            else if (type == typeof(float))
            {
                value.DoubleValue = (float)obj;
            }
            else if (type == typeof(bool))
            {
                value.BooleanValue = (bool)obj;
            }
            else if (type == typeof(DateTime))
            {
                value.TimestampValue = ((DateTime)obj).ToTimestamp();
            }
            else if (type.IsEnum)
            {
                value.IntegerValue = (int)obj;
            }
            else if (typeof(ICollection).IsAssignableFrom(type))
            {
                var list = obj as ICollection;
                value.ArrayValue = new ArrayValue();
                var listType = _typesMetadataLoader.GetTypeMetadata(type);
                if (listType != null && list != null) //TODO: Otherwise should add warn logs
                {
                    foreach (var item in list)
                    {
                        value.ArrayValue.Values.Add(CreateValueFromObject(item));
                    }
                }
            }
            else if (type.IsClass)
            {
                value.EntityValue = new Entity();
                var classMetadata = _typesMetadataLoader.GetTypeMetadata(type);
                if (classMetadata != null)
                {
                    if (!string.IsNullOrEmpty(classMetadata.InheritedClassType))
                    {
                        value.EntityValue.Properties.Add(TypesMetadataLoader.InheritedTypePropertyName, classMetadata.InheritedClassType);
                    }

                    foreach (var property in classMetadata.PropertiesInfo)
                    {
                        var val = property.Value.Get(obj);
                        value.EntityValue.Properties.Add(property.Key, CreateValueFromObject(val, IsExcludeColumnFromIndex(property.Value.CustomAttributes))); // TODO: Should call ToEntity - but should have depth consideration in regarding to the key
                    }
                }
            }

            return value;
        }

        protected TEntity BuildDalEntity(Entity entity)
        {
            var obj = FromEntity(entity, typeof(TEntity));
            var keyPropertyAccessors = GetKeyPropertyAccessors();
            if (_kindKeyInfo.IsAutoGenerated)
            {
                keyPropertyAccessors.Set(obj, entity.Key.Path.First().Id);
            }
            else
            {
                keyPropertyAccessors.Set(obj, entity.Key.Path.First().Name);
            }
            return obj as TEntity;
        }
        private object FromEntity(Entity entity, Type toType)
        {
            var typeMetadata = _typesMetadataLoader.GetTypeMetadata(toType);
            var obj = typeMetadata.Constructor();

            foreach (var property in entity.Properties)
            {
                var propertyName = property.Key;
                if (!typeMetadata.PropertiesInfo.ContainsKey(propertyName))
                {
                    continue;
                    //Warning
                }
                var propertyAccessors = typeMetadata.PropertiesInfo[propertyName];
                propertyAccessors.Set(obj, CreateObjectFromValue(property.Value, propertyAccessors.Type));
            }

            return obj;
        }
        private object CreateObjectFromValue(Value value, Type requestedType)
        {
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.StringValue)
            {
                return value.StringValue;
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.IntegerValue)
            {
                if (requestedType == typeof(int) || requestedType == typeof(int?))
                {
                    return (int)value.IntegerValue;
                }
                if (requestedType.IsEnum)
                {
                    return (int)value.IntegerValue;
                }
                return value.IntegerValue;
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.BooleanValue)
            {
                return value.BooleanValue;
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.DoubleValue)
            {
                return value.DoubleValue;
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.TimestampValue)
            {
                return value.TimestampValue.ToDateTime();
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.EntityValue)
            {
                if (value.EntityValue.Properties.ContainsKey(TypesMetadataLoader.InheritedTypePropertyName)) // Handle abstract class
                {
                    var inheritedTypeName = value.EntityValue.Properties[TypesMetadataLoader.InheritedTypePropertyName].StringValue;
                    var inheritedType = _typesMetadataLoader.GetTypeMetadata(inheritedTypeName);
                    return FromEntity(value.EntityValue, inheritedType);
                }
                return FromEntity(value.EntityValue, requestedType);
            }
            if (value.ValueTypeCase == Value.ValueTypeOneofCase.ArrayValue)
            {
                var typeMetadata = _typesMetadataLoader.GetTypeMetadata(requestedType) as ListMetadata;
                var obj = typeMetadata.Constructor();
                foreach (var item in value.ArrayValue.Values)
                {
                    typeMetadata.AddItem(obj, CreateObjectFromValue(item, typeMetadata.ItemsType));
                }

                return obj;
            }
            return null;
        }

        public async Task<TKey> InsertAsync(TEntity dalEntity)
        {
            var entity = BuildEntity(dalEntity);
            var keys = await _db.InsertAsync(new[] { entity });
            if (keys.Any() && keys[0] == null)
            {
                return GetId(dalEntity);
            }
            // Auto-generated key - set the key property under the entity
            var id = GetId(keys.FirstOrDefault());
            SetId(dalEntity, id);
            return id;
        }
        public async Task<TKey[]> InsertAsync(TEntity[] dalEntities)
        {
            var entities = dalEntities.Select(e => BuildEntity(e)).ToArray();
            var keys = await _db.InsertAsync(entities);
            if (keys.Any() && keys[0] == null)
            {
                return dalEntities.Select(GetId).ToArray();
            }

            // Auto-generated keys - set the keys properties under the entities
            var i = 0;
            var res = new List<TKey>();
            foreach (var key in keys)
            {
                var id = GetId(key);
                SetId(dalEntities[i], id);
                i++;
                res.Add(id);
            }
            return res.ToArray();
        }

        public async Task<TEntity> GetByIdAsync(TKey id)
        {
            var key = BuildKey(id);
            var entity = await _db.LookupAsync(key);
            return entity != null ? BuildDalEntity(entity) : null;
        }

        public async Task DeleteAsync(TKey id)
        {
            var key = BuildKey(id);
            await _db.DeleteAsync(key);
        }
        /// <summary>
        /// Batch delete - notice that you should pass only 1000 max ids
        /// </summary>
        /// <param name="ids"></param>
        /// <returns></returns>
        public async Task DeleteAsync(TKey[] ids)
        {
            if (ids.Length > 1000)
            {
                // TODO throw limit exception + add batch method support
            }
            var keys = ids.Select(BuildKey);
            await _db.DeleteAsync(keys);
        }

        public async Task UpdateAsync(TEntity obj)
        {
            var entity = BuildEntity(obj, true);
            await _db.UpdateAsync(entity);
        }

        private bool IsExcludeColumnFromIndex(IEnumerable<CustomAttributeData> customAttributes)
        {
            return customAttributes.Any(a => a.AttributeType == typeof(ExcludeIndexAttribute));
        }

        public static string GetPropertyName<TProp>(Expression<Func<TEntity, TProp>> expression)
        {
            var memberExpression = expression.Body as MemberExpression;
            return memberExpression?.Member.Name;
        }

    }

    public class KindKeyInfo
    {
        public string KeyName { get; set; }
        public bool IsAutoGenerated { get; set; }
    }
}
